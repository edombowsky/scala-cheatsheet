<%- def includefile(file)
  return File.open(File.dirname(__FILE__) + "/" + file, "rb").read
end -%>

Scala cheatsheet
================

Collections
-----------

### dropWhile

Drops longest prefix of elements that satisfy a predicate.

```scala
def dropWhile(p: (A) ⇒ Boolean): Seq[A]

<%= includefile("dropWhile.scala") %>
```
![graphical dropWhile](images/dropWhile.png)



### filter

Selects all elements of this traversable collection which satisfy a predicate.

```scala
def filter(p: (A) ⇒ Boolean): Seq[A]

<%= includefile("filter.scala") %>
```
![graphical filter](images/filter.png)



### filterNot

Selects all elements of this traversable collection which do not satisfy a predicate.

```scala
def filterNot(p: (A) ⇒ Boolean): Seq[A]

<%= includefile("filterNot.scala") %>
```
![graphical filterNot](images/filterNot.png)



### foldLeft

Applies a binary operator to a start value and all elements of this traversable or iterator, going left to right.

```scala
def foldLeft[B](z: B)(op: (B, A) ⇒ B): B

<%= includefile("foldLeft.scala") %>
```
![graphical foldLeft](images/foldLeft.png)



### foldRight

Applies a binary operator to all elements of this iterable collection and a start value, going right to left.

```scala
def foldRight[B](z: B)(op: (A, B) ⇒ B): B

<%= includefile("foldRight.scala") %>
```
![graphical foldRight](images/foldRight.png)



### map

Builds a new collection by applying a function to all elements of this sequence.

```scala
def map[B](f: A ⇒ B): Seq[B]

<%= includefile("map.scala") %>
```
![graphical map](images/map.png)



### partition

Partitions this traversable collection in two traversable collections according to a predicate.

```scala
def partition(p: (A) ⇒ Boolean): (Seq[A], Seq[A])

<%= includefile("partition.scala") %>
```
![graphical partition](images/partition.png)



### reduceLeft

Applies a binary operator to all elements of this traversable or iterator, going left to right.

```scala
def reduceLeft[B >: A](op: (B, A) ⇒ B): B

<%= includefile("reduceLeft.scala") %>
```
![graphical reduceLeft](images/reduceLeft.png)



### reduceRight

Applies a binary operator to all elements of this iterable collection, going right to left.

```scala
def reduceRight[B >: A](op: (A, B) ⇒ B): B

<%= includefile("reduceRight.scala") %>
```
![graphical reduceRight](images/reduceRight.png)



### sliding

Groups elements in fixed size blocks by passing a "sliding window" over them (as opposed to partitioning them, as is done in grouped.) "Sliding window" step is 1 by default.

```scala
def sliding(size: Int): Iterator[Seq[A]]
def sliding(size: Int, step: Int): Iterator[Seq[A]]

<%= includefile("sliding.scala") %>
```

![graphical sliding](images/sliding.png)



### span

Splits this traversable collection into a prefix/suffix pair according to a predicate.

```scala
def span(p: (A) ⇒ Boolean): (Seq[A], Seq[A])

<%= includefile("span.scala") %>
```
![graphical span](images/span.png)



### takeWhile

Takes longest prefix of elements that satisfy a predicate.

```scala
def takeWhile(p: (A) ⇒ Boolean): Seq[A]

<%= includefile("takeWhile.scala") %>
```
![graphical takeWhile](images/takeWhile.png)



### unzip

Converts this collection of pairs into two collections of the first and second half of each pair.

```scala
def unzip[A1, A2](implicit asPair: (A) ⇒ (A1, A2)): (Seq[A1], Seq[A2])

<%= includefile("unzip.scala") %>
```
![graphical unzip](images/unzip.png)



### zip

Returns a sequence formed from this sequence and another iterable collection by combining corresponding elements in pairs.

```scala
def zip[B](that: GenIterable[B]): Seq[(A, B)]

<%= includefile("zip.scala") %>
```
![graphical zip](images/zip.png)
